# 容器轻量执行框架 LitePodOpsFramework

### 项目简述

#### 项目背景

K8S广泛应用，其中POD资源配额可以防止资源滥用和过度扩展。出于经济考虑，容器的资源配额与业务高度绑定，因此在容器内执行非业务操作需要额外关注资源限制与风险控制，避免影响容器内进程。由于容器技术本身通过NAMESPACE与CGROUP实现隔离控制与资源限制，因此在容器内部无法通过CGROUP进行进一步资源限制。公司基于K8S构建容器集群，时常需要对POD进行批量操作，因此需要一个解决方案。



#### 项目功能

- 定义接入流程，提供符合目标的轻量无干扰的POD操作下发执行通道；
- 支持批量下发，提供多维度的串并行调度控制，避免集中式风险，确保风险可控；
- 多机制确保调度、下发全过程可灰度、可观测与风险可控；



#### 项目难点

- POD容器内无法通过CGROUP直接限制资源；
- 同NAMESPACE受限于同一CGROUP限制，POD外同NS操作无法规避资源竞争困境；
- 没有NS隔离的操作影响范围较大，尤其是变更操作可能影响多POD甚至集群；



#### 项目目标

- 安全、有效、不出错； （操作有效，POD对象准确）

- 轻量无干扰； （不影响集群资源，不影响业务程序）
- 风险可控；（降低风险概率，减小影响范围，避免风险扩散）



### 项目方案设计

#### 操作的读写分离

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps1.png?raw=true)



![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps2.png?raw=true)

- 只读操作：安全性较高，尽可能将相对安全、资源消耗较高的操作放在POD外执行；

  - 在物理机层面通过POD内外映射关系完成，避免与POD内进程直接竞争有限的资源；
  - 通过CGROUP、NAMESPACE进一步对资源、影响范围进行限制；
  - 位于挂载区域内的变更也归于该部分执行；

- 变更操作：存在风险，许多场景无法绕开不同NS问题，通过调度策略来尽量规避竞争；

  - 通过K8S的API在POD内执行，确保执行对相关准确，执行结果有效；
  - 对于可划分的变更操作，进行分批执行，避免变更操作长时间执行引起资源竞争；

  

#### 风险控制

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps3.png?raw=true)

- 多级白名单过滤拦截：确保下发节点准确匹配，同时为灰度部署下发提供容错兜底；
- 串并行调度控制：
  - 支持多维度的串行调度策略，避免集中式风险，限制风险影响范围（单POD级损失）；
  - 非相关的POD间并行调度，提高下发执行效率；
  - 限制最大并行度，控制风险影响范围；
- 观察窗口：确保操作结果可观测性，同时给故障处理留出时间，避免故障链式扩散；
- 熔断机制：
  - 操作故障 => 局部熔断，暂停当前操作的后续调度与执行；
  - POD故障 => 局部熔断，暂停当前操作与其他节点上同POD的调度与执行；
  - 多点故障 => 全局熔断，暂停所有下发，避免风险扩散；
- 行为上报：控制面板将调度行为、操作过程向外部监控组件上报（避免消耗集群与POD的资源），确保全过程可观测，并接入基础架构；



#### 可用性保障

##### 单活示例

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps4.png?raw=true)

##### 多活示例

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps5.png?raw=true)

- 多活方案，确保服务高可用
  - 多活竞争锁，拿到锁的调度器更新心跳，重置锁的持续时间，然后维持调度下发；
  - 竞争失败的调度器陷入睡眠，等待一个稍长时间后重新竞争；
  - 竞争成功的调度器以更短的间隔竞争，尽可能避免调度权的让出；
  - 锁与心跳设置有效时间，避免全局死锁；
- 守护进程自动恢复拉起调度器；
- 自动扫描重建调度索引，避免调度错漏；
- 操作执行失败时自动重试，提供冗余；

