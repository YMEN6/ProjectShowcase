# 云上OPS平台 PodLiteOps

### 背景

金融应用与交易业务已完成上云，部分业务场景下，会对容器内进行临时操作。需要可行的接入框架，对临时操作进行资源限制与风险控制，避免影响容器内业务的正常运行。



### 难点

- 容器资源配额低，且大多处于高负载状态；
- 无法通过容器超卖、扩缩容等手段规避容器内操作的需求；
- 容器内无法再通过CGroup进行资源限制；
- 同NameSpace无法规避资源竞争问题，SideCar方案无法解决问题；



### 目标

- 业务进程正常工作；
- 容器正常工作，不暂停；



### 解决方案

- 剥离拆分“临时操作”中的主要性能开销部分，转移到容器外执行，避免容器内的资源竞争加剧；（进程级别）
- 使用NameSpace与CCgroup对容器外操作进行资源隔离与限制，避免影响其他容器或物理机；（单机级别）



### 项目方案设计

#### 操作的读写分离

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps1.png?raw=true)



![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps2.png?raw=true)

- 只读操作：安全性较高，尽可能将相对安全、资源消耗较高的操作放在POD外执行；

  - 在物理机层面通过POD内外映射关系完成，避免与POD内进程直接竞争有限的资源；
  - 通过CGROUP、NAMESPACE进一步对资源、影响范围进行限制；
  - 位于挂载区域内的变更也归于该部分执行；

- 变更操作：存在风险，许多场景无法绕开不同NS问题，通过调度策略来尽量规避竞争；

  - 通过K8S的API在POD内执行，确保执行对相关准确，执行结果有效；
  - 对于可划分的变更操作，进行分批执行，避免变更操作长时间执行引起资源竞争；

  

#### 风险控制

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps3.png?raw=true)

- 多级白名单过滤拦截：确保下发节点准确匹配，同时为灰度部署下发提供容错兜底；
- 串并行调度控制：
  - 支持多维度的串行调度策略，避免集中式风险，限制风险影响范围（单POD级损失）；
  - 非相关的POD间并行调度，提高下发执行效率；
  - 限制最大并行度，控制风险影响范围；
- 观察窗口：确保操作结果可观测性，同时给故障处理留出时间，避免故障链式扩散；
- 熔断机制：
  - 操作故障 => 局部熔断，暂停当前操作的后续调度与执行；
  - POD故障 => 局部熔断，暂停当前操作与其他节点上同POD的调度与执行；
  - 多点故障 => 全局熔断，暂停所有下发，避免风险扩散；
- 行为上报：控制面板将调度行为、操作过程向外部监控组件上报（避免消耗集群与POD的资源），确保全过程可观测，并接入基础架构；



#### 可用性保障

##### 单活示例

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps4.png?raw=true)

##### 多活示例

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps5.png?raw=true)

- 多活方案，确保服务高可用
  - 多活竞争锁，拿到锁的调度器更新心跳，重置锁的持续时间，然后维持调度下发；
  - 竞争失败的调度器陷入睡眠，等待一个稍长时间后重新竞争；
  - 竞争成功的调度器以更短的间隔竞争，尽可能避免调度权的让出；
  - 锁与心跳设置有效时间，避免全局死锁；
- 守护进程自动恢复拉起调度器；
- 自动扫描重建调度索引，避免调度错漏；
- 操作执行失败时自动重试，提供冗余；

