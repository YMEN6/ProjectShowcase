# 云上OPS平台 LitePodOps

### 背景

金融应用与交易业务已完成上云，部分业务场景下需要对在容器内进行临时的变更操作，要求不能影响原有容器与业务的正常工作；



### 负责模块

部分组件 / 业务会在高峰期快速生成大量文件，导致容器漂移，影响正常服务；



### 难点

- 容器资源配额低，且大多处于高负载状态；
- 容器内无法再通过CGroup进行资源限制；
- 同NameSpace无法规避资源竞争问题，因此SideCar方案无法解决问题；



### 目标

- 对容器进行垃圾文件的兜底清理；
- 单个容器的垃圾清理不能影响容器内进程的正常运行；
- 全局范围的并发清理不能影响业务性能；



### 分析

##### 单容器清理

- 文件清理可以分为文件查找与文件清理两个阶段；
- 查找是主要性能开销；
- 常规清理的性能开销小，但需要注意**”惊群效应“**引起的资源过载与性能下降；

##### 多容器清理

- 并发清理容易引起**”集中式风险“**，导致业务性能出现大范围异常；
- 变更操作需要完备的风险控制与应急处理，避免故障扩散，影响现网服务；



### 解决方案

##### 单容器清理：资源限制

- 通过**读写分离**与**负载转移**，将查找放在容器外执行，避免容器内的资源竞争加剧；
- 通过**CGROUP**对查找进行资源限制，降低对物理机与其他容器的影响；
- 通过**分批变更策略**，将集中的文件清理压力，分摊到一个时间片上，避免清理动作长期霸占容器内资源；
- 通过**RENICE**下降清理操作的进程调度优先级，避免资源竞争；

##### 多容器清理：风险控制

- 通过**串并行调度控制**，规避集中式风险，同时限制故障的影响范围，确保全局范围内最多损失若干个容器；
- 通过**分批灰度策略**，配合观察窗口，确保变更操作的结果可观测，并留出故障处理时间，避免故障快速扩散；
- 通过**多级黑白名单过滤、入口限流、多级熔断**等机制，确保清理变更可控，避免引发大范围故障；



### 具体方案

（这里插入一张，前后端分离的架构图）

#### 资源限制

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps1.png?raw=true)



![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps2.png?raw=true)

- 只读操作：安全性较高，尽可能将相对安全、资源消耗较高的操作放在容器外执行；

  - 在物理机层面通过容器内外映射关系完成，避免与容器内进程直接竞争有限的资源；
  - 通过CGROUP、NAMESPACE进一步对资源、影响范围进行限制；

- 变更操作：存在风险，许多场景无法绕开不同NS问题，通过调度策略来尽量规避竞争；

  - 通过K8S的API在POD内执行，确保执行对相关准确，执行结果有效；
  - 对于可划分的变更操作，进行分批执行，避免变更操作长时间执行引起资源竞争；

  

#### 风险控制

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps3.png?raw=true)

- 多级黑白名单过滤拦截：为灰度部署下发提供容错兜底；
- 串并行调度控制：
  - 支持多维度的串行调度策略，避免集中式风险，限制风险影响范围（单容器级别损失）；
  - 非相关的容器间并行调度，提高下发执行效率；
  - 限制最大并行度，控制风险影响范围；
- 观察窗口：确保操作结果可观测性，同时给故障处理留出时间，避免故障链式扩散；
- 熔断机制：
  - 操作故障 => 局部熔断，暂停当前操作的后续调度与执行；
  - 容器故障 => 局部熔断，暂停当前操作与其他节点上同容器的调度与执行；
  - 多点故障 => 全局熔断，暂停所有下发，避免风险扩散；
- 行为上报：控制面板将调度行为、操作过程向外部监控组件上报（避免消耗集群与容器的资源），确保全过程可观测，并接入基础架构；



#### 可用性保障

##### 单活示例

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps4.png?raw=true)

##### 多活示例

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/LitePodOps5.png?raw=true)

- 多活方案，确保服务高可用
  - 多活竞争锁，拿到锁的调度器更新心跳，重置锁的持续时间，然后维持调度下发；
  - 竞争失败的调度器陷入睡眠，等待一个稍长时间后重新竞争；
  - 竞争成功的调度器以更短的间隔竞争，尽可能避免调度权的让出；
  - 锁与心跳设置有效时间，避免全局死锁；
- 守护进程自动恢复拉起调度器；
- 自动扫描重建调度索引，避免调度错漏；
- 操作执行失败时自动重试，提供冗余；

