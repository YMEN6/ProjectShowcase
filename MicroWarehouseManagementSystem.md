## 微型仓储管理系统 MicroWarehouseManagementSystem(MWMS)

### 项目简述

#### 项目背景

**MicroWarehouseManagementSystem (MWMS)** 是一个专为小型仓储环境设计的管理系统。面对数据量和并发量不高的场景，MWMS使用有限的计算资源，尽可能提供高效的仓储管理服务。该系统致力于在有限资源环境下，尽可能提高操作效率，确保小型仓储的日常运营流畅。



#### 项目功能

- 库存管理：记录、跟踪库存的入库和出库操作，并实时更新库存数量；
- 订单管理：处理客户订单的创建、更新和删除，并追踪订单状态，确保订单及时处理和发货；
- 库存追踪：提供详细的库存位置和数量信息，支持多维度追踪库存；
- 报表生成：自动生成库存和订单报表，提供自定义报表功能，满足不同业务需求；



#### 项目挑战

- 计算资源有限：
  - 硬盘IO较慢，需要减少磁盘IO带来的时间开销
    - 使用redis缓存，并设置异步持久化，提高写入性能
    - 使用合并写回算法，批量写回数据，减少磁盘IO
  - 对外和对内网络不对等，需要对系统提供保护
    - 使用kafka实现”削峰填谷“，避免系统被高并发请求压垮；
    - 使用动态读写分离，必要时降低单机redis读写压力，并提高效率；
  - CPU核心较少，资源紧张
- 性能优化：需要将常用的性能优化方案，根据当前场景进行改进，确保在有限资源下，尽可能提高系统性能



#### 部署环境

##### 计算资源

- CPU：Intel I7 8700， 6 cores 12 threads；
- Memory： 32G；
- Disk：WD20EARZ(7200rpm, 2T, HDD, 80 - 150 MBps)
- Network: 1M(OUTSIDE), 1000M(INSIDE)

##### 系统负载

- redis：4G
- kafka：4个topic, io.threads=4, network.threads=2, replica.fetchers=1;
- 线程池： corePoolSize=6, maximumPoolSize=12；
  - 6 = 12 - 4(for OS) - 2 (for redis);
- 请求队列：100, 000
  - 数据不超出1KB，redis-benchmark测出120,000rps => 120MBps  （场景：读、写、持久化）
  - 按照0.75阈值计算一般负载，120 MBps * 0.75 = 90 MBps
  - 按照4个topic均分，队列长度理论上限为 90MB / 1KB =90, 000;
  - 对外，按照1Mbps网络带宽，每秒最多接收125个1KB数据;对内，1000Mbps，接收能力与redis处理性能相近；
  - 考虑实际场景下，不同业务间的请求分布并不均匀，因此令队列长度为100, 000。当队满时，认为接近redis性能瓶颈，触发读写分离，进行负载均衡；



### 项目架构及设计

#### 总架构

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/mwms1.png?raw=true)

- Kafka：参考HTTP2.0，基于业务对请求进行划分、隔离；
  - 避免非相关业务间的影响，尤其是队头阻塞效应；
  - 降低请求粒度，结合线程池并发执行，提高整体效率；
  - 此外kafka在瞬时大量请求场景下，可对系统提供保护作用；
- Redis：以主从结构部署，面向高、低负载提供不同的工作模式
  - 低负载：主库负责读写，从库用于备份，提供高可用保障；
  - 高负载：主库负责写，从库负责读，降低主库的处理压力，并提高系统效率；



#### 冷热分离

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/mwms2.png?raw=true)

场景说明：业务上的对象，通常只需要对其中的**部分属性**进行读写访问，因此关键在于对这部分属性进行处理；

- 设计层面的冷热分离：基于频率将对象的属性划分为高频属性和低频属性
  - 高频属性(CoreAttrObj)：读取频率高、实时要求高，通常较小，且数目多；
  - 低频属性(ExtAttrObj)：读取频率低，实时性要求较低，通常较大，但数目少；
- 部署层面的冷热分离：redis缓存有限，因此通过设置失效时间，让重要数据尽可能存活在缓存；
  - 高频属性：过期时间设置为24h + 随机撒盐，且每次**访问时重置**；
  - 低频属性：过期时间设置为4h + 随机撒盐，每次访问**延长1h**；
  - 不论高频属性或者低频属性，都将整体存入，而不是拆分为单独属性存入
    - 当前场景下，分布式锁方案会加剧redis性能压力与系统整体复杂度，但性能优势并不显著；
    - 缺点：伪共享问题并没有解决（拆分能缓解这一问题）
- 数据库写回(磁盘IO)的冷热分离：
  - 高频属性：高频属性修改频繁，为了确保数据一致性，发生修改时**立即写回**DB；
  - 低频属性：低频属性修改频率低，修改内容大，实时要求性低，频繁写对DB性能负载大，因此采取**合并写回**策略；



#### 动态读写分离

![](https://github.com/YMEN6/ProjectShowcase/blob/main/picture/mwms3.png?raw=true)

场景说明：redis的读写，基于负载自适应调整，主要目标是提升高负载场景下数据读取的效率，并降低redis单机读写压力；

- 低负载场景：主库负责读写，从库提供备份，确保缓存的高可用
  - 基于业务划分的多个队列之间并发处理请求，队列内部按FIFO处理；
  - 队列间相互独立，因此不需要考虑队列并发竞争问题；
  - 队列内部以串行方式处理，同样不需要考虑并发问题；
  - redis的主线程读写以串行方式进行，简单读写场景下，其性能上限与内网千兆网络性能相近；
  - 此时业务负载轻，计算资源有限，不做额外优化；
- 当发生队列已满，但kafka中仍有请求，进入高负载场景，触发动态读写分离；
- 高负载场景：主库负责写，从库负责读；
  - 原队列拆分为读队列和写队列，两个队列并发处理；
  - 写队列中的请求使用主库进行处理，读队列中的请求则使用从库进行处理；
  - 当读队列的队头任务序号小于写队列的队头任务序号时，读早于写，此时直接读取从库数据（认为从库已经完成备份）并返回；
  - 否则，若读取**高频属性**，则返回**读取失败**，若读取**低频属性**，则**直接读取**并返回；





